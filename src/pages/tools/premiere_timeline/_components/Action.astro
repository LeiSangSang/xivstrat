---
import type { ImageMetadata } from 'astro'
import type { Role } from '../role'
import { Image } from 'astro:assets'

interface Props {
  duty: string
  icon?: ImageMetadata
  role: Role
  recast: number
  duration: number
  physical: number
  magical: number
  special: number
}

const { duty, icon = undefined, role, recast, duration, physical, magical, special }: Props = Astro.props
---

<ff14-action
  class="flex w-16 flex-col items-center -space-y-1"
  data-duty={duty}
  data-role={role}
  data-recast={recast}
  data-duration={duration}
  data-physical={physical}
  data-magical={magical}
  data-special={special}
>
  <div class="relative">
    <div class="relative aspect-[88/91] w-16">
      <slot>
        {icon && <Image src={icon} alt="" />}
      </slot>
      <div
        class="pointer-events-none absolute inset-0 opacity-0 brightness-0"
        data-masktype="recast"
        style="mask: conic-gradient(from 0deg at 50% 50%, transparent 0deg, black 0deg);"
      >
        <slot>
          {icon && <Image src={icon} alt="" />}
        </slot>
      </div>
    </div>
    <span
      class="absolute top-[calc(50%-2px)] left-1/2 -translate-x-1/2 -translate-y-1/2 text-4xl font-semibold opacity-0 text-shadow-lg/50"
      data-spantype="recast"
    >
      00
    </span>
  </div>
  <span
    class="text-3xl font-semibold text-[#68FC64] opacity-0 text-shadow-[#3C8E3E] text-shadow-xs"
    data-spantype="duration"
  >
    00
  </span>
</ff14-action>

<script>
  import { animate } from 'motion'

  import { timeToSeconds } from '@/lib/utils'

  import type { Role } from '../role'

  import { $mitigations } from '../_stores/mitigation'
  import { $timer } from '../_stores/timer'
  import { timelineMap } from '../timeline'

  class FF14Action extends HTMLElement {
    connectedCallback() {
      const duty = this.dataset.duty! as keyof typeof timelineMap
      const recastSpan = this.querySelector('[data-spantype="recast"]')!
      const durationSpan = this.querySelector('[data-spantype="duration"]')!
      const recastMask = this.querySelector('[data-masktype="recast"]')! as HTMLElement
      const role = this.dataset.role as Role
      const recast = Number.parseInt(this.dataset.recast ?? '0')
      const duration = Number.parseInt(this.dataset.duration ?? '0')
      const physical = Number.parseInt(this.dataset.physical ?? '100')
      const magical = Number.parseInt(this.dataset.magical ?? '100')
      const special = Number.parseInt(this.dataset.special ?? '100')
      const plan = timelineMap[duty].mitigations[role].map((t) => timeToSeconds(t))
      $timer.subscribe((timer) => {
        const s = timer / 1000
        // 找到最大的不超过 s 的时间点
        const t = plan.filter((t) => t <= s).reduce((max, t) => (t > max ? t : max), -Infinity)
        if (t === -Infinity) {
          return
        }
        // 分情况
        if (s - t < recast) {
          // 显示遮罩并更新径向裁剪
          animate(recastMask, { opacity: 0.75 })
          const progress = (s - t) / recast // 0到1的进度（已冷却的比例）
          const completedAngle = progress * 360 // 已完成的角度

          // 使用conic-gradient创建径向遮罩，从12点钟位置开始顺时针
          // transparent部分是已冷却的（不遮罩），black部分是未冷却的（遮罩）
          recastMask.style.mask = `conic-gradient(from 0deg at 50% 50%, transparent 0deg, transparent ${completedAngle}deg, black ${completedAngle}deg, black 360deg)`

          // recastSpan 展示
          animate(recastSpan, { opacity: 1 })
          recastSpan.textContent = `${Math.ceil(recast - (s - t))}`
        } else {
          // recastSpan 隐藏
          animate(recastMask, { opacity: 0 })
          animate(recastSpan, { opacity: 0 })
        }
        if (s - t < duration) {
          // durationSpan 展示
          animate(durationSpan, { opacity: 1 })
          durationSpan.textContent = `${Math.ceil(duration - (s - t))}`
          const mitigation = $mitigations.get()[role]
          if (
            Math.floor(mitigation[0] * 100) !== physical ||
            Math.floor(mitigation[1] * 100) !== magical ||
            Math.floor(mitigation[2] * 100) !== special
          ) {
            $mitigations.setKey(role, [physical / 100, magical / 100, special / 100])
          }
        } else {
          // durationSpan 隐藏
          animate(durationSpan, { opacity: 0 })

          const mitigation = $mitigations.get()[role]
          if (
            Math.floor(mitigation[0] * 100) !== 100 ||
            Math.floor(mitigation[1] * 100) !== 100 ||
            Math.floor(mitigation[2] * 100) !== 100
          ) {
            $mitigations.setKey(role, [1, 1, 1])
          }
        }
      })
    }
  }

  customElements.define('ff14-action', FF14Action)
</script>
